{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Taikai extends the capabilities of the popular ArchUnit library by offering a comprehensive suite of predefined rules tailored for various technologies. It simplifies the enforcement of architectural constraints and best practices in your codebase, ensuring consistency and quality across your projects.</p> <p>Get Started View on GitHub </p>"},{"location":"#example-usage","title":"Example Usage","text":"<pre><code>class ArchitectureTest {\n\n  @Test\n  void shouldFulfilConstraints() {\n    Taikai.builder()\n        .namespace(\"com.company.project\")\n        .java(java -&gt; java\n            .noUsageOfDeprecatedAPIs()\n            .classesShouldImplementHashCodeAndEquals()\n            .methodsShouldNotDeclareGenericExceptions()\n            .utilityClassesShouldBeFinalAndHavePrivateConstructor()\n            .imports(imports -&gt; imports\n                .shouldHaveNoCycles()\n                .shouldNotImport(\"..internal..\"))\n            .naming(naming -&gt; naming\n                .classesShouldNotMatch(\".*Impl\")\n                .methodsShouldNotMatch(\"^(foo$|bar$).*\")\n                .fieldsShouldNotMatch(\".*(List|Set|Map)$\")\n                .constantsShouldFollowConventions()\n                .interfacesShouldNotHavePrefixI()))            \n        .test(test -&gt; test\n            .junit(junit -&gt; junit\n                .classesShouldNotBeAnnotatedWithDisabled()\n                .methodsShouldNotBeAnnotatedWithDisabled()))\n        .logging(logging -&gt; logging\n            .loggersShouldFollowConventions(Logger.class, \"logger\", List.of(PRIVATE, FINAL)))\n        .spring(spring -&gt; spring\n            .noAutowiredFields()\n            .boot(boot -&gt; boot\n                .applicationClassShouldResideInPackage())\n            .configurations(configuration -&gt; configuration\n                .namesShouldEndWithConfiguration()\n                .namesShouldMatch(\"regex\"))\n            .controllers(controllers -&gt; controllers\n                .shouldBeAnnotatedWithRestController()\n                .namesShouldEndWithController()\n                .namesShouldMatch(\"regex\")\n                .shouldNotDependOnOtherControllers()\n                .shouldBePackagePrivate()))\n        .services(services -&gt; services\n            .namesShouldEndWithService()\n            .shouldBeAnnotatedWithService())\n        .repositories(repositories -&gt; repositories\n            .namesShouldEndWithRepository()\n            .shouldBeAnnotatedWithRepository())\n        .build()\n        .check();\n  }\n}\n</code></pre>"},{"location":"#sponsors","title":"Sponsors","text":"<p>If Taikai has helped you save time and money, I invite you to support my work by becoming a sponsor. By becoming a sponsor, you enable me to continue to improve Taikai's capabilities by fixing bugs immediately and continually adding new useful features. Your sponsorship plays an important role in making Taikai even better.</p>"},{"location":"#backers","title":"Backers","text":"<p>The Open Source Community and Enofex </p>"},{"location":"#license","title":"License","text":"<p>See LICENSE.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Thank you for your interest in contributing to Taikai! We welcome contributions from the community to help make the project even better. Here are some ways you can get involved:</p> <ul> <li> <p>Star the Project:</p> <ul> <li>Show your support by starring the project   on GitHub.</li> <li>This helps increase visibility and encourages others to discover and contribute to the   project.</li> </ul> </li> <li> <p>Review the Contribution Guide:</p> <ul> <li>Familiarize yourself with the guidelines and procedures outlined in our contribution guide.</li> <li>The contribution guide provides detailed information on how to get started and the different   ways   you can contribute.</li> </ul> </li> <li> <p>Follow Contribution Guidelines:</p> <ul> <li>Ensure that you follow our   contribution guidelines   when submitting your contributions.</li> <li>These guidelines cover aspects such as code formatting, documentation standards, and other   important considerations.</li> </ul> </li> <li> <p>Pull Requests:</p> <ul> <li>If you have improvements or fixes to propose, submit a Pull Request (PR) to the relevant   module or repository.</li> <li>Clearly describe the purpose and changes made in your PR, providing enough context for the   reviewers to understand your contribution.</li> <li>Be open to feedback and engage in discussions to refine your contribution.</li> </ul> </li> <li> <p>Bug Reports and Feature Requests:</p> <ul> <li>Help us improve Taikai by reporting any bugs or issues you encounter.</li> <li>If you have ideas for new features or enhancements, submit a feature request.</li> <li>Use the issue tracker in the respective repository to provide detailed information about the   problem or request.</li> </ul> </li> <li> <p>Spread the Word:</p> <ul> <li>Share your positive experience with Taikai and encourage others to contribute.</li> <li>Tweet about your contributions, write blog posts, or mention Taikai in relevant communities   to increase awareness.</li> </ul> </li> <li> <p>Help with Documentation:</p> <ul> <li>Contribute to improving the documentation by identifying areas that need clarification or   adding examples and tutorials.</li> <li>Submit documentation PRs to enhance the usability and understanding of Taikai.</li> </ul> </li> </ul> <p>Remember, contributions of all sizes are valuable and appreciated. We look forward to your involvement in the Taikai community. Thank you for considering contributing to the project!</p>"},{"location":"contributing/#sponsor","title":"Sponsor","text":"<p>Sponsor Taikai on GitHub </p>"},{"location":"documentation/","title":"Taikai","text":""},{"location":"documentation/#1-introduction","title":"1. Introduction","text":"<p>Taikai is an automated architecture testing tool for Java projects designed to maintain clean and consistent architecture. It enforces predefined and custom architectural constraints, ensuring code quality, maintainability, and adherence to best practices.</p>"},{"location":"documentation/#2-getting-started","title":"2. Getting Started","text":"<p>To use Taikai, include it as a dependency in your Maven <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.enofex&lt;/groupId&gt;\n    &lt;artifactId&gt;taikai&lt;/artifactId&gt;\n    &lt;version&gt;${taikai.version}&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Ensure to configure <code>${taikai.version}</code> to the latest stable version compatible with your project's ArchUnit version.</p>"},{"location":"documentation/#3-usage","title":"3. Usage","text":""},{"location":"documentation/#31-setting-the-namespace","title":"3.1 Setting the Namespace","text":"<p>The <code>namespace</code> setting specifies the base package of your project. Taikai will analyze all classes within this namespace. The default mode is <code>WITHOUT_TESTS</code>, which excludes test classes from the import check.</p> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .build()\n    .check();\n</code></pre>"},{"location":"documentation/#32-setting-the-javaclasses","title":"3.2 Setting the JavaClasses","text":"<p>You can configure <code>classes</code> as well. This allows you to specify specific Java classes to analyze. Note that setting both <code>namespace</code> and <code>classes</code> simultaneously is not supported and will result in an <code>IllegalArgumentException</code>.</p> <pre><code>JavaClasses classes = new ClassFileImporter()\n    .importClasses(ClassToCheck.class)\n\nTaikai.builder()\n    .classes(classes)\n    .build()\n    .check();\n\nOr:\n\nTaikai.builder()\n    .classes(ClassToCheck.class)\n    .build()\n    .check();\n</code></pre>"},{"location":"documentation/#33-enforcing-rules-on-empty-sets","title":"3.3 Enforcing Rules on Empty Sets","text":"<p>The <code>failOnEmpty</code> setting determines whether the build should fail if no classes match a given rule. This is useful to ensure that your rules are applied consistently and to avoid false positives. The default is <code>false</code>.</p> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .failOnEmpty(true)\n    .build()\n    .check();\n</code></pre>"},{"location":"documentation/#34-excluding-classes-globally","title":"3.4 Excluding Classes Globally","text":"<p>You can exclude classes from all rule checks using <code>excludeClasses(...)</code> on the <code>Taikai.Builder</code>.</p> <p>Supported patterns:</p> <ul> <li> <p>Fully qualified class name <code>com.company.project.foo.ClassToExclude</code></p> </li> <li> <p>Package wildcard (<code>*</code>) \u2013 classes directly in the package <code>com.company.project.foo.*</code></p> </li> <li> <p>Recursive package wildcard (<code>..</code>) \u2013 package and all subpackages <code>com.company.project.internal..</code></p> </li> </ul> <p>Example:</p> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .excludeClasses(\n        \"com.company.project.foo.ClassToExclude\",\n                \"com.company.project.bar.*\",\n                \"com.company.project.internal..\")\n    .build()\n    .check();\n</code></pre>"},{"location":"documentation/#35-modifying-an-existing-configuration","title":"3.5 Modifying an Existing Configuration","text":"<p>The <code>toBuilder</code> method allows you to create a new Builder instance from an existing Taikai configuration. This is useful if you need to modify an existing configuration.</p> <pre><code>Taikai taikai = Taikai.builder()\n    .namespace(\"com.company.project\")\n    .excludeClasses(\"com.company.project.SomeClassToExclude\")\n    .failOnEmpty(true)\n    .java(java -&gt; java\n        .fieldsShouldNotBePublic())\n    .build();\n\n// Modify the existing configuration\nTaikai modifiedTaikai = taikai.toBuilder()\n    .namespace(\"com.company.newproject\")\n    .excludeClasses(\"com.company.project.AnotherClassToExclude\")\n    .failOnEmpty(false)\n    .java(java -&gt; java\n        .classesShouldImplementHashCodeAndEquals()\n        .finalClassesShouldNotHaveProtectedMembers())\n    .build();\n\n// Perform the check with the modified configuration\nmodifiedTaikai.check();\n</code></pre>"},{"location":"documentation/#36-check-method-usage","title":"3.6 Check Method Usage","text":""},{"location":"documentation/#361-check-with-fail-fast","title":"3.6.1 Check with Fail Fast","text":"<p>The <code>check()</code> method performs the rule checks and fails immediately when the first violation is encountered. This is the default behavior, ensuring that the process halts as soon as a failure occurs.</p> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .build()\n    .check();  // Stops on the first failure\n</code></pre>"},{"location":"documentation/#362-check-without-fail-fast","title":"3.6.2  Check without Fail Fast","text":"<p>The <code>checkAll()</code> method allows you to evaluate all rules and collect all failures before throwing an exception. It aggregates all violations and throws an exception with a detailed failure report once all rules are processed. This is useful when you want to see all the issues without stopping at the first failure.</p> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .build()\n    .checkAll();  // Collects all errors before failing\n</code></pre>"},{"location":"documentation/#4-rules-overview","title":"4. Rules Overview","text":"<p>Taikai's architecture rules cover a wide range of categories to enforce best practices and maintain consistency.</p>"},{"location":"documentation/#java-rules","title":"Java Rules","text":"<p>The default mode is <code>WITHOUT_TESTS</code>, which excludes test classes from the import check.</p> Category Method Name Rule Description General <code>classesShouldImplementHashCodeAndEquals</code> Classes should implement <code>hashCode</code> and <code>equals</code> together. General <code>classesShouldResideInPackage</code> Classes matching specific naming patterns should reside in a specified package. General <code>classesAnnotatedWithShouldResideInPackage</code> Classes annotated with a specific annotation should reside in a specified package. General <code>classesAnnotatedWithShouldNotBeAnnotatedWith</code> Classes annotated with a specific annotation should not be annotated with a specified annotation. General <code>classesAnnotatedWithShouldHaveModifiers</code> Classes annotated with a specific annotation should have specified modifiers. General <code>classesAnnotatedWithShouldNotHaveModifiers</code> Classes annotated with a specific annotation should not have specified modifiers. General <code>classesAnnotatedWithShouldBeRecords</code> Classes annotated with a specific annotation should be records. General <code>classesShouldResideOutsidePackage</code> Classes matching specific naming patterns should reside outside a specified package. General <code>classesShouldBeAnnotatedWith</code> Classes matching specific naming patterns should be annotated with a specified annotation. General <code>classesShouldBeAnnotatedWithAll</code> Classes annotated with a specific annotation should be annotated with a specified annotations. General <code>classesShouldNotBeAnnotatedWith</code> Classes matching specific naming patterns should not be annotated with a specified annotation. General <code>classesShouldBeAssignableTo</code> Classes matching specific naming patterns should be assignable to a certain type. General <code>classesShouldImplement</code> Classes matching specific naming patterns should implement to a interface. General <code>classesShouldHaveModifiers</code> Classes matching specific naming patterns should have specified modifiers. General <code>classesShouldNotHaveModifiers</code> Classes matching specific naming patterns should not have specified modifiers. General <code>classesShouldBeRecords</code> Classes matching specific naming patterns should be records. General <code>fieldsShouldHaveModifiers</code> Fields matching specific naming patterns should have specified modifiers. General <code>fieldsShouldNotBePublic</code> Fields should not be <code>public</code>, except constants. General <code>fieldsAnnotatedWithShouldHaveModifiers</code> Fields annotated with a specific annotation should have specified modifiers. General <code>fieldsAnnotatedWithShouldNotHaveModifiers</code> Fields annotated with a specific annotation should not have specified modifiers. General <code>methodsShouldNotDeclareGenericExceptions</code> Methods should not declare generic exceptions, like <code>Exception</code> or <code>RuntimeException</code>. General <code>methodsShouldNotDeclareException</code> Methods with names matching a specified pattern should not declare a specified exception type. General <code>methodsShouldBeAnnotatedWith</code> Methods matching specific naming patterns should be annotated with a specified annotation. General <code>methodsShouldBeAnnotatedWithAll</code> Methods annotated with a specific annotation should be annotated with a specified annotations. General <code>methodsAnnotatedWithShouldNotBeAnnotatedWith</code> Methods annotated with a specific annotation should not be annotated with a specified annotation. General <code>methodsAnnotatedWithShouldHaveModifiers</code> Methods annotated with a specific annotation should have specified modifiers. General <code>methodsAnnotatedWithShouldNotHaveModifiers</code> Methods annotated with a specific annotation should not have specified modifiers. General <code>methodsShouldHaveModifiers</code> Methods matching specific naming patterns should have specified modifiers. General <code>methodsShouldNotHaveModifiers</code> Methods matching specific naming patterns should not have specified modifiers. General <code>methodsShouldHaveModifiersForClass</code> Methods in a class matching specific naming patterns should have specified modifiers. General <code>methodsShouldNotHaveModifiersForClass</code> Methods in a class matching specific naming patterns should not have specified modifiers. General <code>methodsShouldNotExceedMaxParameters</code> Methods in a class should not have more than the specified maximum number of parameters. General <code>noUsageOf</code> Disallow usage of specific classes. General <code>noUsageOfDeprecatedAPIs</code> No usage of deprecated APIs annotated with <code>@Deprecated</code>. General <code>noUsageOfSystemOutOrErr</code> Disallow usage of <code>System.out</code> or <code>System.err</code>. General <code>utilityClassesShouldBeFinalAndHavePrivateConstructor</code> Utility classes with only <code>static</code> methods (except <code>main</code>) should be <code>final</code> and have a private constructor. General <code>finalClassesShouldNotHaveProtectedMembers</code> Classes declared as <code>final</code> should not contain any <code>protected</code> members. General <code>serialVersionUIDShouldBeStaticFinalLong</code> Fields named <code>serialVersionUID</code> should be declared as <code>static final long</code>. Imports <code>shouldHaveNoCycles</code> No cyclic dependencies in imports. Imports <code>shouldImport</code> Check for specific imports (e.g., <code>..allow..</code>). Imports <code>shouldNotImport</code> Disallow specific imports (e.g., <code>..disallow..</code>). Naming <code>packagesShouldMatchDefault</code> Packages should match <code>^[a-z_]+(\\.[a-z_][a-z0-9_]*)*$</code> naming patterns. Naming <code>packagesShouldMatch</code> Packages should match specific naming patterns. Naming <code>classesShouldNotMatch</code> Classes should not match specific naming patterns (e.g., <code>.*Impl</code>). Naming <code>classesAnnotatedWithShouldMatch</code> Classes annotated with a specific annotation should match specific naming patterns. Naming <code>classesImplementingShouldMatch</code> Classes implementing a specific interface should match specific naming patterns. Naming <code>classesAssignableToShouldMatch</code> Classes assignable to a certain type should match specific naming patterns. Naming <code>methodsShouldNotMatch</code> Methods should not match specific naming patterns. Naming <code>methodsAnnotatedWithShouldMatch</code> Methods annotated with a specific annotation should match specific naming patterns. Naming <code>fieldsShouldNotMatch</code> Fields should not match specific naming patterns. Naming <code>fieldsShouldMatch</code> Fields should match specific naming patterns for specific classes. Naming <code>fieldsAnnotatedWithShouldMatch</code> Fields annotated with a specific annotation should match specific naming patterns. Naming <code>constantsShouldFollowConventions</code> Constants should follow naming conventions, except <code>serialVersionUID</code>. Naming <code>interfacesShouldNotHavePrefixI</code> Interfaces should not have the prefix <code>I</code>."},{"location":"documentation/#logging-rules","title":"Logging Rules","text":"<p>The default mode is <code>WITHOUT_TESTS</code>, which checks only test classes.</p> Category Method Name Rule Description General <code>loggersShouldFollowConventions</code> Ensure that specified loggers follow specific naming patterns and have the required modifiers. General <code>classesShouldUseLogger</code> Ensure that classes matching a given regex have a field of a specified logger type."},{"location":"documentation/#test-rules","title":"Test Rules","text":"<p>The default mode is <code>ONLY_TESTS</code>, which checks only test classes.</p> Category Method Name Rule Description JUnit <code>classesShouldBePackagePrivate</code> Ensure that classes whose names match a specific naming pattern are declared as package-private. JUnit <code>classesShouldNotBeAnnotatedWithDisabled</code> Ensure classes are not annotated with <code>@Disabled</code>. JUnit <code>methodsShouldBePackagePrivate</code> Ensure that test methods annotated with <code>@Test</code> or <code>@ParameterizedTest</code> are package-private. JUnit <code>methodsShouldNotBeAnnotatedWithDisabled</code> Ensure methods are not annotated with <code>@Disabled</code>. JUnit <code>methodsShouldBeAnnotatedWithDisplayName</code> Ensure that test methods annotated with <code>@Test</code> or <code>@ParameterizedTest</code> are annotated with <code>@DisplayName</code>. JUnit <code>methodsShouldMatch</code> Ensure that test methods annotated with <code>@Test</code> or <code>@ParameterizedTest</code> have names matching a specific regex pattern. JUnit <code>methodsShouldNotDeclareExceptions</code> Ensure that test methods annotated with <code>@Test</code> or <code>@ParameterizedTest</code> do not declare any thrown exceptions. JUnit <code>methodsShouldContainAssertionsOrVerifications</code> Ensure that test methods annotated with <code>@Test</code> or <code>@ParameterizedTest</code> contain at least one assertion or verification."},{"location":"documentation/#spring-rules","title":"Spring Rules","text":"<p>The default mode is <code>WITHOUT_TESTS</code>, which excludes test classes from the import check.</p> Category Method Name Rule Description General <code>noAutowiredFields</code> Fields should not be annotated with <code>@Autowired</code>, prefer constructor injection. Boot <code>applicationClassShouldResideInPackage</code> Ensure <code>@SpringBootApplication</code> is in the default package. Properties <code>namesShouldEndWithProperties</code> Properties annotated with <code>@ConfigurationProperties</code> should end with <code>Properties</code>. Properties <code>namesShouldMatch</code> Properties annotated with <code>@ConfigurationProperties</code> should match a regex pattern. Properties <code>shouldBeAnnotatedWithValidated</code> Properties annotated with <code>@ConfigurationProperties</code> should be annotated with <code>@Validated</code>. Properties <code>shouldBeAnnotatedWithConfigurationProperties</code> Properties ending with <code>Properties</code> should be annotated with <code>@ConfigurationProperties</code>. Properties <code>shouldBeRecords</code> Properties annotated with <code>@ConfigurationProperties</code> should be records. Configurations <code>namesShouldEndWithConfiguration</code> Configurations annotated with <code>@Configuration</code> should end with <code>Configuration</code>. Configurations <code>namesShouldMatch</code> Configurations annotated with <code>@Configuration</code> should match a regex pattern. Controllers <code>namesShouldEndWithController</code> Controllers annotated with <code>@Controller</code> or <code>@RestController</code> should end with <code>Controller</code>. Controllers <code>namesShouldMatch</code> Controllers annotated with <code>@Controller</code> or <code>@RestController</code> should match a regex pattern. Controllers <code>shouldBeAnnotatedWithController</code> Controllers ending with <code>Controller</code> should be annotated with <code>@Controller</code>. Controllers <code>shouldBeAnnotatedWithRestController</code> Controllers ending with <code>Controller</code> should be annotated with <code>@RestController</code>. Controllers <code>shouldBeAnnotatedWithValidated</code> Controllers annotated with <code>@Controller</code> or <code>@RestController</code> or match a regex pattern, containing methods having a parameter annotated with <code>@PathVariable</code> or <code>@RequestParam</code> and a validation annotation (e.g., <code>@Min</code>, <code>@NotNull</code>, etc.), should also be annotated with <code>@Validated</code>. Controllers <code>shouldBePackagePrivate</code> Controllers annotated with <code>@Controller</code> or <code>@RestController</code> should be package-private. Controllers <code>shouldNotDependOnOtherControllers</code> Controllers annotated with <code>@Controller</code> or <code>@RestController</code> should not depend on other controllers annotated with <code>@Controller</code> or <code>@RestController</code>. Repositories <code>namesShouldEndWithRepository</code> Repositories annotated with <code>@Repository</code> should end with <code>Repository</code>. Repositories <code>namesShouldMatch</code> Repositories annotated with <code>@Repository</code> should match a regex pattern. Repositories <code>shouldBeAnnotatedWithRepository</code> Repositories ending with <code>Repository</code> should be annotated with <code>@Repository</code>. Repositories <code>shouldNotDependOnServices</code> Repositories annotated with <code>@Repository</code> should not depend on service classes annotated with <code>@Service</code>. Services <code>namesShouldEndWithService</code> Services annotated with <code>@Service</code> should end with <code>Service</code>. Services <code>namesShouldMatch</code> Services annotated with <code>@Service</code> should match a regex pattern. Services <code>shouldBeAnnotatedWithService</code> Services ending with <code>Service</code> should be annotated with <code>@Service</code>. Services <code>shouldNotDependOnControllers</code> Services annotated with <code>@Service</code> should not depend on controllers annotated with <code>@Controller</code> or <code>@RestController</code>."},{"location":"documentation/#quarkus-rules","title":"Quarkus Rules","text":"<p>The default mode is <code>WITHOUT_TESTS</code>, which excludes test classes from the import check.</p> Category Method Name Rule Description General <code>noInjectionFields</code> Fields must not be annotated with <code>@Inject</code>, use constructor injection. Resources <code>namesShouldEndWithResource</code> Classes annotated with <code>@Path</code> should have names ending with <code>Resource</code>. Resources <code>namesShouldMatch</code> Resource classes annotated with <code>@Path</code> should match a given regex pattern. Resources <code>shouldBeAnnotatedWithPath</code> Classes matching a resource naming pattern should be annotated with <code>@Path</code>. Resources <code>shouldBePublic</code> Resource classes annotated with <code>@Path</code> should be public. Resources <code>shouldNotDependOnOtherResources</code> Resource classes annotated with <code>@Path</code> should not depend on other resource classes. Panache <code>shouldBeAnnotatedWithEntityWhenActiveRecordPattern</code> Classes extending <code>PanacheEntity</code> (Active Record pattern) must be annotated with <code>@Entity</code>. Panache <code>namesShouldEndWithRepository</code> Classes implementing <code>PanacheRepository</code> should have names ending with <code>Repository</code>. Panache <code>namesShouldMatch</code> Classes implementing <code>PanacheRepository</code> should match a given regex pattern. AI <code>namesShouldEndWithAssistantOrResource</code> AI services annotated with <code>@RegisterAiService</code> should have names ending with <code>Assistant</code> or <code>Service</code>. AI <code>namesShouldMatch</code> AI services annotated with <code>@RegisterAiService</code> should match a given regex pattern. AI <code>shouldBeAnnotatedWithApplicationScoped</code> AI services annotated with <code>@RegisterAiService</code> must also be annotated with <code>@ApplicationScoped</code>. AI <code>shouldNotUseToolsAttributeInAiService</code> AI services must not define tools via the <code>tools</code> attribute of <code>@RegisterAiService</code>; use <code>@Toolbox</code> instead."},{"location":"documentation/#5-java-rules","title":"5. Java Rules","text":"<p>Java configuration involves defining constraints related to Java language features, coding standards, and architectural patterns.</p> <ul> <li>No Usage of Deprecated APIs: Ensure that deprecated APIs annotated with <code>@Deprecated</code> not used in the codebase.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .noUsageOfDeprecatedAPIs())\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Should Implement <code>hashCode</code> and <code>equals</code> together: Ensure that classes override the <code>hashCode</code> and <code>equals</code> methods together.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesShouldImplementHashCodeAndEquals())\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Should Reside in Specified Package: Ensure that classes matching a specific regex pattern reside in the specified package.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesShouldResideInPackage(\".*Utils\", \"com.company.project.utils\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Should Reside in Specified Package: Ensure that classes reside in the specified package.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesShouldResideInPackage(\"com.company.project..\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Annotated with a Specified Annotation Should Reside in Specified Package: Ensure that classes annotated with a specific annotation reside in the specified package.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesAnnotatedWithShouldResideInPackage(PublicApi.class, \"com.company.project.api\")    \n        .classesAnnotatedWithShouldResideInPackage(\"com.company.project.PublicApi\", \"com.company.project.api\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Annotated with a Specified Annotation Should not be annotated with a Specified Annotation.: Ensure that classes annotated with a specific not also be annotated with another specified annotation.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesAnnotatedWithShouldNotBeAnnotatedWith(PublicApi.class, InternalApi.class)    \n        .classesAnnotatedWithShouldNotBeAnnotatedWith(\"com.company.project.PublicApi\", \"com.company.project.InternalApi\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Annotated with a Specified Annotation Should Have Specified Modifiers.: Ensure that any class annotated with a given annotation should have all required modifiers.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesAnnotatedWithShouldHaveModifiers(PublicApi.class, List.of(PUBLIC, FINAL))\n        .classesAnnotatedWithShouldHaveModifiers(\"com.company.project.PublicApi\", List.of(PUBLIC, FINAL)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Annotated with a Specified Annotation Should Not Have Specified Modifiers.: Ensure that any class annotated does not have one or more forbidden modifiers.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesAnnotatedWithShouldNotHaveModifiers(PublicApi.class, List.of(PUBLIC, FINAL))\n        .classesAnnotatedWithShouldNotHaveModifiers(\"com.company.project.PublicApi\", List.of(PUBLIC, FINAL)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes annotated with a Specified Annotation Should Be Records: Ensure that any class annotated with a given annotation are records.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesShouldBeRecords(Configuration.class))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Should Reside outside Specified Package: Ensure that classes matching a specific regex pattern reside outside the specified package.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesShouldResideOutsidePackage(\".*Dto\", \"com.company.project.domain\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Should Be Annotated with Specified Annotation: Ensure that classes matching a specific regex pattern are annotated with the specified annotation.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesShouldBeAnnotatedWith(\".*Api\", PublicApi.class)\n        .classesShouldBeAnnotatedWith(\".*Api\", \"com.company.project.PublicApi\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Annotated with a Specified Annotation Should Be Annotated with Specified Annotations: Ensure that classes annotated with a specific annotation should be annotated with the specified annotations.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesShouldBeAnnotatedWithAll(RestController.class, List.of(RequestMapping.class))\n        .classesShouldBeAnnotatedWithAll(\"org.springframework.web.bind.annotation.RestController\", List.of(\"org.springframework.web.bind.annotation.RequestMapping\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Should Not Be Annotated with Specified Annotation: Ensure that classes matching a specific regex pattern are not annotated with the specified annotation.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesShouldNotBeAnnotatedWith(\".*Internal\", PublicApi.class)\n        .classesShouldNotBeAnnotatedWith(\".*Internal\", \"com.company.project.PublicApi\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Should Be Assignable to a Specified Type: Ensure that classes are matching a specific regex pattern assignable to a certain type.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesShouldBeAssignableTo(\".*Repository\", BaseRepository.class)\n        .classesShouldBeAssignableTo(\".*Repository\", \"com.company.project.BaseRepository\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Should Implement a Specified Interface: Ensure that classes matching a specific regex pattern implement a certain interface.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesShouldImplement(\".*Repository\", CrudRepository.class)\n        .classesShouldImplement(\".*Repository\", \"org.springframework.data.repository.CrudRepository\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Should Have Specified Modifiers: Ensure that classes matching a specific regex pattern have a certain modifier.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesShouldHaveModifiers(\".*Repository\", List.of(PUBLIC)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Should Not Have Specified Modifiers: Ensure that classes matching a specific regex pattern have not a certain modifier.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesShouldNotHaveModifiers(\".*Repository\", List.of(PUBLIC)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Classes Should Be Records: Ensure that classes matching a specific regex pattern a records.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .classesShouldBeRecords(\".*DTO\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Methods Should Not Throw Generic Exception: Ensure that methods do not throw generic exceptions like <code>Exception</code> and <code>RuntimeException</code> and use specific exception types instead.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .methodsShouldNotDeclareGenericExceptions())\n    .build()\n    .check();\n</code></pre> <ul> <li>Methods Should Not Declare Specific Exception: Ensure that methods with names matching a specified pattern do not declare a specified exception type.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .methodsShouldNotDeclareException(\"should*\", SpecificException.class)\n        .methodsShouldNotDeclareException(\"should*\", \"com.company.project.SpecificException\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Methods Should Be Annotated with Specified Annotation: Ensure that methods matching a specific regex pattern are annotated with the specified annotation.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .methodsShouldBeAnnotatedWith(\".*Api\", PublicApi.class)\n        .methodsShouldBeAnnotatedWith(\".*Api\", \"com.company.project.PublicApi\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Methods Annotated with a Specified Annotation Should Be Annotated with Specified Annotations: Ensure that methods annotated with a specific annotation should be annotated with the specified annotations.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .methodsShouldBeAnnotatedWithAll(Modifying.class, List.of(Transactional.class, Query.class))\n        .methodsShouldBeAnnotatedWithAll(\"org.springframework.data.jpa.repository.Modifying\", List.of(\"org.springframework.transaction.annotation.Transactional\", \"org.springframework.data.jpa.repository.Query\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Methods Annotated with a Specified Annotation Should not be annotated with a Specified Annotation.: Ensure that methods annotated with a specific annotation not also be annotated with another specified annotation.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .methodsAnnotatedWithShouldNotBeAnnotatedWith(PublicApi.class, InternalApi.class)    \n        .methodsAnnotatedWithShouldNotBeAnnotatedWith(\"com.company.project.PublicApi\", \"com.company.project.InternalApi\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>Methods Annotated with a Specified Annotation Should Have a Specified Modifiers.: Ensure that methods annotated with a specific annotation have a certain modifier.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .methodsAnnotatedWithShouldHaveModifiers(DisplayName.class, List.of(PUBLIC))\n        .methodsAnnotatedWithShouldHaveModifiers(\"org.junit.jupiter.api.DisplayName\", List.of(PUBLIC)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Methods Annotated with a Specified Annotation Should Not Have a Specified Modifiers.: Ensure that methods annotated with a specific annotation not have a certain modifier.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .methodsAnnotatedWithShouldHaveModifiers(DisplayName.class, List.of(PUBLIC))\n        .methodsAnnotatedWithShouldHaveModifiers(\"org.junit.jupiter.api.DisplayName\", List.of(PUBLIC)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Methods Should Have Specified Modifiers: Ensure that methods matching a specific regex pattern have a certain modifier.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .methodsShouldHaveModifiers(\".*methodRegex\", List.of(PUBLIC)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Methods Should Not Have Specified Modifiers: Ensure that methods matching a specific regex pattern have not a certain modifier.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .methodsShouldNotHaveModifiers(\".*methodRegex\", List.of(PUBLIC)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Methods Should Have Specified Modifiers: Ensure that methods matching a specific regex pattern have a certain modifier.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .methodsShouldHaveModifiersForClass(\".*classRegex\", List.of(PUBLIC)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Methods Should Not Have Specified Modifiers: Ensure that methods matching a specific regex pattern have not certain modifier.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .methodsShouldNotHaveModifiersForClass(\".*classRegex\", List.of(PUBLIC)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Methods Should Not Exceed a Maximum Number of Parameters:: Ensure that methods in classes do not have more than the specified maximum number of parameters.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .methodsShouldNotExceedMaxParameters(10)\n    .build()\n    .check();\n</code></pre> <ul> <li>Utility Classes Should Be Final and Have Private Constructor: Ensure that utility classes with only <code>static</code> methods except <code>main</code> should be declared as <code>final</code> and have <code>private</code> constructors to prevent instantiation.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .utilityClassesShouldBeFinalAndHavePrivateConstructor())\n    .build()\n    .check();\n</code></pre> <ul> <li>Fields Should Have Modifiers: Ensure that fields matching a specific naming pattern have the required modifiers.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.enofex.taikai\")\n    .java(java -&gt; java\n        .fieldsShouldHaveModifiers(\"^[A-Z][A-Z0-9_]*$\", List.of(STATIC, FINAL)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Fields Annotated with a Specified Annotation Should Have Specified Modifiers.: Ensure that any fields annotated with a given annotation should have all required modifiers.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .fieldsAnnotatedWithShouldHaveModifiers(Constant.class, List.of(PUBLIC, STATIC, FINAL))\n        .fieldsAnnotatedWithShouldHaveModifiers(\"com.company.project.annotations.Constant\", List.of(PUBLIC, STATIC, FINAL)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Fields Annotated with a Specified Annotation Should Not Have Specified Modifiers.: Ensure that any fields annotated does not have one or more forbidden modifiers.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .fieldsAnnotatedWithShouldNotHaveModifiers(Autowired.class, List.of(STATIC))\n        .fieldsAnnotatedWithShouldNotHaveModifiers(\"org.springframework.beans.factory.annotation.Autowired\", List.of(STATIC)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Fields Should Not Be Public: Ensure that no fields in your Java classes are declared as <code>public</code>, except constants.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.enofex.taikai\")\n    .java(java -&gt; java\n        .fieldsShouldNotBePublic())\n    .build()\n    .check();\n</code></pre> <ul> <li>Ensure <code>serialVersionUID</code> is <code>static final long</code>: Ensure that fields named <code>serialVersionUID</code> are declared as <code>static final long</code>.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .serialVersionUIDShouldBeStaticFinalLong())\n    .build()\n    .check();\n</code></pre> <ul> <li>Imports Configuration: Ensure that there are no cyclic dependencies in imports, check for imports or disallow specific imports.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .imports(imports -&gt; imports\n            .shouldHaveNoCycles()\n            .shouldImport(\".*Service\", \"com.company.project.BusinessException\")\n            .shouldNotImport(\"..internal..\")\n            .shouldNotImport(lombok())\n            .shouldNotImport(\".*Service\", \"com.company.project.SpecificException\")))\n    .build()\n    .check();\n</code></pre> <ul> <li>Naming Configuration: Define naming conventions for packages, classes, methods, fields, constants and interfaces.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .naming(naming -&gt; naming\n            .packagesShouldMatchDefault()\n            .packagesShouldMatch(\"regex\")\n            .classesShouldNotMatch(\".*Impl\")\n            .classesAnnotatedWithShouldMatch(Annotation.class, \"coolClass\")   \n            .classesAnnotatedWithShouldMatch(\"com.company.project.Annotation\", \"coolClass\")   \n            .classesImplementingShouldMatch(Configurer.class, \".*Configurer\")\n            .classesImplementingShouldMatch(\"com.company.project.Configurer\", \".*Configurer\")\n            .classesAssignableToShouldMatch(AbstractConfigurer.class, \".*Configurer\")\n            .classesAssignableToShouldMatch(\"com.company.project.AbstractConfigurer\", \".*Configurer\")\n            .methodsShouldNotMatch(\"coolMethod\")\n            .methodsAnnotatedWithShouldMatch(Annotation.class, \"coolMethods\")\n            .methodsAnnotatedWithShouldMatch(\"com.company.project.Annotation\", \"coolMethods\")  \n            .fieldsShouldNotMatch(\"coolField\")\n            .fieldsShouldMatch(Annotation.class, \"coolField\")\n            .fieldsShouldMatch(\"com.company.project.Annotation\", \"coolField\")\n            .fieldsAnnotatedWithShouldMatch(Annotation.class, \"coolField\")\n            .fieldsAnnotatedWithShouldMatch(\"com.company.project.Annotation\", \"coolField\")  \n            .constantsShouldFollowConventions()\n            .interfacesShouldNotHavePrefixI())))\n    .build()\n    .check();\n</code></pre> <ul> <li>No Usage of Specific Classes: Ensure that certain classes are not used in your codebase.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .noUsageOf(UnwantedClass.class)\n        .noUsageOf(UnwantedClass.class, \"in.specific.package\")\n        .noUsageOf(\"com.example.UnwantedClass\")\n        .noUsageOf(\"com.example.UnwantedClass\", \"in.specific.package\"))\n    .build()\n    .check();\n</code></pre> <ul> <li>No Usage of <code>System.out</code> or <code>System.err</code>: Enforce disallowing the use of <code>System.out</code> and <code>System.err</code> for logging, encouraging the use of proper logging frameworks instead.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .noUsageOfSystemOutOrErr())\n    .build()\n    .check();\n</code></pre> <ul> <li>Ensure Final Classes Do Not Have Protected Members: Ensures that classes declared as <code>final</code> do not contain any <code>protected</code> members. Since <code>final</code> classes cannot be subclassed, having <code>protected</code> members is unnecessary.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .finalClassesShouldNotHaveProtectedMembers())\n    .build()\n    .check();\n</code></pre>"},{"location":"documentation/#6-logging-rules","title":"6. Logging Rules","text":"<p>Logging configuration involves specifying constraints related to logging frameworks and practices.</p> <ul> <li>Ensure Logger Field Conforms to Standards: Ensure that classes use a logger field of the specified type, with the correct name and optionally required modifiers.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .logging(logging -&gt; logging\n        .loggersShouldFollowConventions(org.slf4j.Logger.class, \"logger\")\n        .loggersShouldFollowConventions(\"org.slf4j.Logger\", \"logger\")\n        .loggersShouldFollowConventions(org.slf4j.Logger.class, \"logger\", List.of(PRIVATE, FINAL))\n        .loggersShouldFollowConventions(\"org.slf4j.Logger\", \"logger\", List.of(PRIVATE, FINAL)))\n    .build()\n    .check();\n</code></pre> <ul> <li>Ensure Classes Use Specified Logger: Ensure that classes matching a given regex have a field of a specified logger type.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .logging(logging -&gt; logging\n        .classesShouldUseLogger(org.slf4j.Logger.class, \".*Service\")\n        .classesShouldUseLogger(\"org.slf4j.Logger\", \".*Service\"))\n    .build()\n    .check();\n</code></pre>"},{"location":"documentation/#7-test-rules","title":"7. Test Rules","text":"<p>Test configuration involves specifying constraints related to testing frameworks and practices.</p> <ul> <li>JUnit Configuration: Ensure that JUnit test classes and methods are not annotated with <code>@Disabled</code>.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .test(test -&gt; test\n        .junit(junit -&gt; junit\n            .classesShouldNotBeAnnotatedWithDisabled()\n            .methodsShouldNotBeAnnotatedWithDisabled()))\n    .build()\n    .check();\n</code></pre> <ul> <li>Ensure Test Methods are Package-Private: Ensure that JUnit test methods annotated with <code>@Test</code> or <code>@ParameterizedTest</code> are package-private.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .test(test -&gt; test\n        .junit(junit -&gt; junit\n            .methodsShouldBePackagePrivate()))\n    .build()\n    .check();\n</code></pre> <ul> <li>Ensure Test Methods are Annotated with <code>@DisplayName</code>: Ensure that JUnit test methods annotated with <code>@Test</code> or <code>@ParameterizedTest</code> are also annotated with <code>@DisplayName</code> to provide descriptive test names.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .test(test -&gt; test\n        .junit(junit -&gt; junit\n            .methodsShouldBeAnnotatedWithDisplayName()))\n    .build()\n    .check();\n</code></pre> <ul> <li>Ensure Test Methods Follow Naming Convention: Ensure that JUnit test methods annotated with <code>@Test</code> or <code>@ParameterizedTest</code> have names matching a specific regex pattern.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .test(test -&gt; test\n        .junit(junit -&gt; junit\n            .methodsShouldMatch(\"regex\")))\n    .build()\n    .check();\n</code></pre> <ul> <li>Ensure Test Methods Do Not Declare Thrown Exceptions: Ensure that JUnit test methods annotated with <code>@Test</code> or <code>@ParameterizedTest</code> do not declare any thrown exceptions.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .test(test -&gt; test\n        .junit(junit -&gt; junit\n            .methodsShouldNotDeclareExceptions()))\n    .build()\n    .check();\n</code></pre> <ul> <li>Ensure Classes with Matching Names are Package-Private: Ensure that classes whose names match a specified regex pattern are declared as package-private.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .test(test -&gt; test\n        .junit(junit -&gt; junit\n            .classesShouldBePackagePrivate(\".*Test\")))\n    .build()\n    .check();\n</code></pre> <ul> <li> <p>Ensure Test Methods Contain Assertions or Verifications: Ensure that test methods annotated with <code>@Test</code> or <code>@ParameterizedTest</code> contain at least one assertion or verification.</p> <ul> <li>JUnit: Ensure the use of assertions from <code>org.junit.jupiter.api.Assertions</code>.</li> <li>Mockito: Ensure the use of verification methods from <code>org.mockito.Mockito</code> like <code>verify</code>, <code>inOrder</code>, or <code>capture</code>.</li> <li>Hamcrest: Ensure the use of assertions from <code>org.hamcrest.MatcherAssert</code>.</li> <li>AssertJ: Ensure the use of assertions from <code>org.assertj.core.api.Assertions</code>.</li> <li>Truth: Ensure the use of assertions from <code>com.google.common.truth.Truth</code>.</li> <li>Cucumber: Ensure the use of assertions from <code>io.cucumber.java.en.Then</code> or <code>io.cucumber.java.en.Given</code>.</li> <li>Spring MockMvc: Ensure the use of assertions from <code>org.springframework.test.web.servlet.MockMvc</code> like <code>andExpect</code> or <code>andDo</code>.</li> <li>ArchUnit: Ensure the use of the <code>check</code> method from <code>com.tngtech.archunit.lang.ArchRule</code>.</li> <li>Taikai: Ensure the use of the <code>check</code> method from <code>com.enofex.taikai.Taikai</code>.</li> </ul> </li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .test(test -&gt; test\n        .junit(junit -&gt; junit\n            .methodsShouldContainAssertionsOrVerifications()))\n    .build()\n    .check();\n</code></pre>"},{"location":"documentation/#8-spring-rules","title":"8. Spring Rules","text":"<p>Spring configuration involves defining constraints specific to Spring Framework usage.</p> <ul> <li>No Autowired Fields Configuration: Ensure that fields are not annotated with <code>@Autowired</code> and constructor injection is preferred.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .spring(spring -&gt; spring\n        .noAutowiredFields())\n    .build()\n    .check();\n</code></pre> <ul> <li>Spring Boot Configuration: Ensure that the main application class annotated with <code>@SpringBootApplication</code> is located in the default package.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .spring(spring -&gt; spring\n        .boot(boot -&gt; boot\n            .applicationClassShouldResideInPackage(\"com.company.project\")))\n    .build()\n    .check();\n</code></pre> <ul> <li>Properties Configuration: Ensure that configuration property classes end with <code>Properties</code> or match a specific regex pattern, are annotated with <code>@ConfigurationProperties</code>, annotated with <code>@Validated</code> or are records.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .spring(spring -&gt; spring\n        .properties(properties -&gt; properties\n            .shouldBeAnnotatedWithConfigurationProperties()\n            .namesShouldEndWithProperties()\n            .namesShouldMatch(\"regex\")\n            .shouldBeRecords()\n            .shouldBeAnnotatedWithValidated()))\n    .build()\n    .check();\n</code></pre> <ul> <li>Configurations Configuration: Ensure that configuration classes end with <code>Configuration</code> or match a specific regex pattern.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .spring(spring -&gt; spring\n        .configurations(configuration -&gt; configuration\n            .namesShouldEndWithConfiguration()\n            .namesShouldMatch(\"regex\")))\n    .build()\n    .check();\n</code></pre> <ul> <li>Controllers Configuration: Ensure that controller classes end with <code>Controller</code> or match a specific regex pattern, are annotated with <code>@RestController</code>, do not depend on other controllers, has set <code>@Validated</code> correctly, or are package-private.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .spring(spring -&gt; spring\n        .controllers(controllers -&gt; controllers\n            .shouldBeAnnotatedWithRestController()\n            .namesShouldEndWithController()\n            .shouldBeAnnotatedWithValidated()\n            .namesShouldMatch(\"regex\")\n            .shouldNotDependOnOtherControllers()\n            .shouldBePackagePrivate()))\n    .build()\n    .check();\n</code></pre> <ul> <li>Services Configuration: Ensure that service classes end with <code>Service</code> or match a specific regex pattern and are annotated with <code>@Service</code> and do not depend on other controllers.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .spring(spring -&gt; spring\n        .services(services -&gt; services\n            .shouldBeAnnotatedWithService()    \n            .shouldNotDependOnControllers()\n            .namesShouldMatch(\"regex\")\n            .namesShouldEndWithService()))\n    .build()\n    .check();\n</code></pre> <ul> <li>Repositories Configuration: Ensure that repository classes end with <code>Repository</code> or match a specific regex pattern and are annotated with <code>@Repository</code> and not depend on classes annotated with <code>@Service</code>.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .spring(spring -&gt; spring\n        .repositories(repositories -&gt; repositories\n            .shouldNotDependOnServices()\n            .shouldBeAnnotatedWithRepository()\n            .namesShouldMatch(\"regex\")\n            .namesShouldEndWithRepository()))\n    .build()\n    .check();\n</code></pre>"},{"location":"documentation/#9-quarkus-rules","title":"9. Quarkus Rules","text":"<p>Quarkus configuration involves defining constraints specific to Quarkus usage.</p> <ul> <li>No Injection Fields Configuration: Ensure that fields are not annotated with <code>@Inject</code> and constructor injection is preferred.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .quarkus(quarkus -&gt; quarkus\n        .noInjectionFields())\n    .build()\n    .check();\n</code></pre> <ul> <li>Resources Configuration: Ensure that REST resource classes follow naming, visibility, annotation, and dependency rules.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .quarkus(quarkus -&gt; quarkus\n        .resources(resources -&gt; resources\n            .namesShouldEndWithResource()\n            .namesShouldMatch(\"regex\")\n            .shouldBeAnnotatedWithPath()\n            .shouldBePublic()\n            .shouldNotDependOnOtherResources()))\n    .build()\n    .check();\n</code></pre> <ul> <li>Panache Configuration: Ensure that Panache entities and repositories follow naming and annotation conventions.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .quarkus(quarkus -&gt; quarkus\n        .panache(panache -&gt; panache\n            .shouldBeAnnotatedWithEntityWhenActiveRecordPattern()\n            .namesShouldEndWithRepository()\n            .namesShouldMatch(\"regex\")))\n    .build()\n    .check();\n</code></pre> <ul> <li>AI Services Configuration: Ensure that AI services using LangChain4j follow naming, scoping, and tool registration conventions.</li> </ul> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .quarkus(quarkus -&gt; quarkus\n        .ai(ai -&gt; ai\n            .namesShouldEndWithAssistantOrResource()\n            .namesShouldMatch(\"regex\")\n            .shouldBeAnnotatedWithApplicationScoped()\n            .shouldNotUseToolsAttributeInAiService()))\n    .build()\n    .check();\n</code></pre>"},{"location":"documentation/#10-using-default-rule-profiles","title":"10. Using Default Rule Profiles","text":"<p>Taikai allows you to define reusable rule profiles \u2013 preconfigured sets of rules that can be applied to a project with a single call. This is useful if you want to enforce the same architecture rules across multiple modules or repositories while keeping the rule configuration readable and maintainable.</p> <p>A profile is implemented as a <code>Customizer&lt;T&gt;</code>, where <code>T</code> is the corresponding configurer type (e.g. <code>JavaConfigurer</code>, <code>TestConfigurer</code>, \u2026). Profiles can be reused as-is or combined with additional project-specific rules.</p> <pre><code>Taikai.builder()\n      .namespace(\"com.enofex.taikai\")\n      .java(java -&gt; {\n        DEFAULT_JAVA_PROFILE.customize(java); // apply predefined profile\n        java.classesShouldHaveModifiers(\".*\", List.of(PRIVATE, FINAL)); // add project-specific rule\n      })\n      .test(DEFAULT_TEST_PROFILE) // use profile directly\n      .build()\n      .checkAll();\n\nprivate static final Customizer&lt;JavaConfigurer&gt; DEFAULT_JAVA_PROFILE = java -&gt; {\n  java.noUsageOf(Date.class)\n      .fieldsShouldNotBePublic();\n      // \u2026 more rules \u2026\n};\n\nprivate static final Customizer&lt;TestConfigurer&gt; DEFAULT_TEST_PROFILE = test -&gt; {\n  test.junit(junit -&gt; junit\n      .methodsShouldBePackagePrivate()\n      .methodsShouldMatch(\"should.*\")\n      .methodsShouldContainAssertionsOrVerifications()\n      .classesShouldBePackagePrivate(\".*Test\")\n      .classesShouldNotBeAnnotatedWithDisabled());\n      // \u2026 more rules \u2026\n};\n</code></pre>"},{"location":"documentation/#11-customization","title":"11. Customization","text":""},{"location":"documentation/#custom-configuration-for-import-rules","title":"Custom Configuration for Import Rules","text":"<p>For every rule, you have the flexibility to add a custom configuration. This allows you to specify the namespace, import options, and exclude specific classes from the checks.</p> <p>The <code>Configuration</code> class offers various static methods to create custom configurations: - <code>Configuration.of(String namespace)</code> to set a custom namespace. - <code>Configuration.of(Namespace.IMPORT namespaceImport)</code> to specify import options such as <code>WITHOUT_TESTS</code>, <code>WITH_TESTS</code>, or <code>ONLY_TESTS</code>. - <code>Configuration.of(String namespace, Namespace.IMPORT namespaceImport)</code> to set both namespace and import options. - <code>Configuration.of(JavaClasses javaClasses)</code> to directly provide a set of Java classes. - <code>Configuration.of(Collection&lt;String&gt; excludedClasses)</code> to exclude specific classes from the checks.  - <code>Configuration.of(Collection&lt;Class&gt; excludedClasses)</code> to exclude specific classes from the checks. - Additional overloaded methods to combine these options in various ways.</p> <p>If a <code>namespaceImport</code> is not explicitly provided, it defaults to <code>Namespace.IMPORT.WITHOUT_TESTS</code>.</p> <p>Here's an example of how you can use these methods to create a custom configuration:</p> <pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .java(java -&gt; java\n        .imports(imports -&gt; imports\n            .shouldNotImport(\"..internal..\", Configuration.of(\"com.company.project.different\", Namespace.IMPORT.WITHOUT_TESTS))\n            .shouldNotImport(lombok(), Configuration.of(Namespace.IMPORT.ONLY_TESTS))))\n    .build()\n    .check();\n</code></pre> <p>In this example, the import rule is configured to apply to classes within the specified namespace, excluding test classes.</p>"},{"location":"documentation/#adding-custom-archunit-rules","title":"Adding Custom ArchUnit Rules","text":"<p>In addition to the predefined rules provided by Taikai, you can also add custom ArchUnit rules to tailor the architecture testing to your specific project requirements. Here's how you can integrate custom rules into your Taikai configuration:</p> <p><pre><code>Taikai.builder()\n    .namespace(\"com.company.project\")\n    .addRule(TaikaiRule.of(...)) // Add custom ArchUnit rule here\n    .build()\n    .check();\n</code></pre> By using the <code>addRule()</code> method and providing a custom ArchUnit rule, you can extend Taikai's capabilities to enforce additional architectural constraints that are not covered by the predefined rules. This flexibility allows you to adapt Taikai to suit the unique architectural needs of your Java project.</p>"},{"location":"documentation/#12-examples","title":"12. Examples","text":"<p>Below are some examples demonstrating the usage of Taikai to define and enforce architectural rules in Java projects, including Spring-specific configurations:</p> <pre><code>class ArchitectureTest {\n\n  @Test\n  void shouldFulfilConstraints() {\n    Taikai.builder()\n        .namespace(\"com.company.project\")\n        .java(java -&gt; java\n            .noUsageOfDeprecatedAPIs()\n            .classesShouldImplementHashCodeAndEquals()\n            .methodsShouldNotDeclareGenericExceptions()\n            .utilityClassesShouldBeFinalAndHavePrivateConstructor())\n        .test(test -&gt; test\n            .junit(junit -&gt; junit\n                .classesShouldNotBeAnnotatedWithDisabled()\n                .methodsShouldNotBeAnnotatedWithDisabled()))\n        .logging(logging -&gt; logging\n            .loggersShouldFollowConventions(Logger.class, \"logger\", List.of(PRIVATE, FINAL)))\n        .spring(spring -&gt; spring\n            .noAutowiredFields()\n            .boot(boot -&gt; boot\n                .applicationClassShouldResideInPackage())\n            .configurations(configuration -&gt; configuration\n                .namesShouldEndWithConfiguration()\n                .namesShouldMatch(\"regex\"))\n            .controllers(controllers -&gt; controllers\n                .shouldBeAnnotatedWithRestController()\n                .namesShouldEndWithController()\n                .namesShouldMatch(\"regex\")\n                .shouldNotDependOnOtherControllers()\n                .shouldBePackagePrivate()))\n            .services(services -&gt; services\n                .namesShouldEndWithService()\n                .shouldBeAnnotatedWithService())        \n            .repositories(repositories -&gt; repositories\n                .namesShouldEndWithRepository()\n                .shouldBeAnnotatedWithRepository())\n        .build()\n        .check();\n  }\n}\n</code></pre>"}]}